'use strict';

module.exports = function(server){
	var neuron=require('./jobs');
	var Handler = require('./handler');
	server.jobManager = new neuron.JobManager({
	    
	    // TODO -> option cache is programmed but not tested !!
	    // cache: {
	    //   db: server.db
	    // },
	    
	});

	function isEmpty(obj) {
	    for(var prop in obj) {
	        if(obj.hasOwnProperty(prop))
	            return false;
	    }

	    return true;
	}

	server.get(/^\/rest3d\/jobs/, function (req, res, next) {
		var handler = new Handler(req, res, next);
		var result = {};
		for(var job in server.jobManager.jobs){
			result[job]=[];
			server.jobManager.jobs[job].list.forEach(function(jobId){
				result[job].push(jobId)
			})
		}
	  handler.handleResult(result);
	});

	server.get(/^\/rest3d\/job\/status.*/, function (req, res, next) {
		var handler = new Handler(req, res, next);
	    handler.allowOrigin();
	    var result = {};
    	var id = req.url.stringAfter('/status/');
    	for(var job in server.jobManager.jobs){
			var worker = server.jobManager.jobs[job].getWorker(id);
			var pos = server.jobManager.jobs[job].list.indexOf(id);
			if(worker!==null){
				server.jobManager.jobs[job].queue.forEach(function(jobId){
					if(jobId==id){
						result.status={"queued":server.jobManager.jobs[job].getPosition(id)}
					}
				})
				for(var wait in server.jobManager.jobs[job].waiting){
					if(wait==id){
						result.status="paused";
					}
				}
				for(var run in server.jobManager.jobs[job].running){
					if(run==id){
						result.status="running";
					}
				}
				result.stderr = worker.stderr;
				result.stdout = worker.stdout;
				result.errorCode = worker.errorCode;
			}
			else if(pos!==-1){
				result.status="done";
				result.stderr = server.jobManager.jobs[job].objectById[id].stderr;
				result.stdout = server.jobManager.jobs[job].objectById[id].stdout;
				result.errorCode = server.jobManager.jobs[job].objectById[id].errorCode;
			}
		}
		if(isEmpty(result)){
			handler.handleResult("Any jobs found associated to this id");
		}
		else{
			handler.handleResult(result);
		}
	});

	server.get(/^\/rest3d\/kill\/job.*/, function (req, res, next) {
		var handler = new Handler(req, res, next);
	    handler.allowOrigin();
	    var result = {};
    	var id = req.url.stringAfter('/job/');
    	for(var job in server.jobManager.jobs){
			var worker = server.jobManager.jobs[job].getWorker(id);
			if(worker!==null){
				worker.finished = true;
				handler.redirect(req.url.split("job").join("status").split("kill").join("job"));
				var flag = true;
			}
		}
		if(!flag)handler.handleResult("Any jobs found associated to this id");
	});

	server.get(/^\/rest3d\/suspend\/job.*/, function (req, res, next) {
		var handler = new Handler(req, res, next);
	    handler.allowOrigin();
	    var result = {};
    	var id = req.url.stringAfter('/job/');
		handler.handleResult("Remi I need your help for this, how should I suspend/resume a job? Node js is a one thread model. The only thing I see is to get the pid generated by the thread child process and send a SIGTSTP signal to it");
	});

	server.get(/^\/rest3d\/resume\/job.*/, function (req, res, next) {
		var handler = new Handler(req, res, next);
	    handler.allowOrigin();
	    var result = {};
    	var id = req.url.stringAfter('/job/');
		handler.handleResult("Remi I need your help for this, how should I suspend/resume a job? Node js is a one thread model. The only thing I see is to get the pid generated by the thread child process and send a SIGTSTP signal to it");
	});

}